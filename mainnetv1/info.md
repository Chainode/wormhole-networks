# Wormhole Mainnet

This Wormhole mainnet connects the following chains:

- Solana [Mainnet Beta](https://docs.solana.com/clusters#mainnet-beta).

- Ethereum Mainnet.

## Network parameters

Gossip network name:

    /wormhole/mainnet/1

Gossip bootstrap node:

    /dns4/wormhole-mainnet-bootstrap.certus.one/udp/8999/quic/p2p/12D3KooWNMWC62BBEGgwuvTP1RGroSKbn8DNRubUKBcGwkrDk9dy

Connected chain contracts:

| Network             | Bridge contract addresss                       |
|---------------------|------------------------------------------------|
| Ethereum Mainnet    | [`0xf92cD566Ea4864356C5491c177A430C222d7e678`](https://etherscan.io/address/0xf92cD566Ea4864356C5491c177A430C222d7e678) (verified on Etherscan) |
| Solana Mainnet Beta | [`WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC`](https://explorer.solana.com/address/WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC?cluster=mainnet-beta) |

A copy of the contract binaries that were deployed can be found in [artifacts/](artifacts), along with a pointer to the
Wormhole revision that they were built from.

## Guardian set

Current generation: **0**, containing only the Certus One bootstrap node with the
address `0x7580aA7e036dC199bF0E152C71004716AE0AA747`.

See [v1.prototext](guardianset/v1.prototxt) for the first guardian set update that will be executed once everyone's
node on the network is live.

## Example command line options

Refer to the [operations guide](https://github.com/certusone/wormhole/blob/master/docs/operations.md) on how to set up a node.

```bash
/usr/local/bin/guardiand bridge \
    --bootstrap "/dns4/wormhole-mainnet-bootstrap.certus.one/udp/8999/quic/p2p/12D3KooWNMWC62BBEGgwuvTP1RGroSKbn8DNRubUKBcGwkrDk9dy"
    --network "/wormhole/mainnet/1" \
    --ethContract "0xf92cD566Ea4864356C5491c177A430C222d7e678" \
    --solanaBridgeAddress WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC \  # <-- Solana Bridge address, same as the agent (NEW)
    --solanaRPC http://solana-host:8899 \                                # <-- Solana RPC URI, same as the agent (NEW)
    --solanaWS ws://solana-devnet:8900 \                                 # <-- Solana websocket URI, same as the agent (NEW)
    --nodeName "Certus One" \                                            # <-- your node's name (for network explorer usage)
    --nodeKey /opt/wormhole/keys/wormhole-node.key \                     # <-- auto-generated node key
    --bridgeKey /opt/wormhole/keys/wormhole-guardian.key \               # <-- your guardian key generated by "guardiand keygen"
    --ethRPC wss://ethereum-node.example.com/ws/v3/[...] \               # <-- your ETH full/light node websocket URI
    --adminSocket /run/guardiand/admin.socket \
    --agentRPC /run/guardiand/agent.socket
```

```bash
/usr/local/bin/guardiand-solana-agent \
    --bridge WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC \
    --rpc http://solana-host:8899 \     # <-- URL of your Solana validator RPC server
    --ws ws://solana-devnet:8900 \      # <-- Websocket path to your Solana validator PubSub port (RPC port +1)
    --keypair /path/to/feepayer.json \  # <-- Keypair of a Solana fee payer account with ~10 SOL in it
    --socket /run/guardiand/agent.socket
```

Your fee payer account should be funded with at least 15 SOL and not drop below 5 SOL.

## Contract verification

### Ethereum

Ethereum contracts are easily verified by standard tooling, for example, Etherscan's contract verification which
Wormhole's source code was uploaded to:

- [Wormhole.sol](https://etherscan.io/address/0xf92cD566Ea4864356C5491c177A430C222d7e678#contracts)
- [WrappedAsset.sol](https://etherscan.io/address/0x9A5e27995309a03f8B583feBdE7eF289FcCdC6Ae#contracts)

### Solana

On Solana, first compile the contract using the exact same version of the toolchain. The Wormhole dev environment pins
all dependencies to achieve a reproducible build:

```bash
cd wormhole/solana
git checkout 6d555789d6ad45aa52e011cc6b2ceea2482c23ef  # v1.1.1

docker build -t wormhole-contract .
docker create --name wormhole-contract wormhole-contract
docker cp wormhole-contract:/opt/solana/deps/spl_bridge.so wormhole.so
docker rm wormhole-contract

sha256sum wormhole.so
```

The checksum should be `6524eafd9053cc83b64ce72991b736128893e1fad6012cdf19ec62ebc01cacfc`.

Now, compare it with the contract deployed on-chain. First, get the program account:

```bash
$ solana account WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC --output json 
{
  "pubkey": "WormT3McKhFJ2RkiGpdw9GKvNCrB2aB54gb2uV9MfQC",
  "account": {
    "lamports": 1141440,
    "data": [
      "AgAAAH5VK8SIzjJfGYZa4THx+KM/cW+pztMZ/o1tqTpBMLK/",
      "base64"
    ],
    "owner": "BPFLoaderUpgradeab1e11111111111111111111111",
    "executable": true,
    "rentEpoch": 145
  }
}
```

The address of the program data is stored in the program account's data:

```
00000000  02 00 00 00 7e 55 2b c4 88 ce 32 5f 19 86 5a e1
00000010  31 f1 f8 a3 3f 71 6f a9 ce d3 19 fe 8d 6d a9 3a
00000020  41 30 b2 bf
```

Drop the `02 00 00 00` prefix (=upgradeable program) and convert the address to Base58. You'll get
`9W9hLqpqjncrV1iYf2D3dt6WQMthM2SBBQ9Q5Rr6ueLn` ([example conversion using CyberChef](https://gchq.github.io/CyberChef/#recipe=JPath_expression('account.data%5B0%5D','%5C%5Cn')From_Base64('A-Za-z0-9%2B/%3D',true)Drop_bytes(0,4,false)To_Base58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz')&input=ewogICJwdWJrZXkiOiAiV29ybVQzTWNLaEZKMlJraUdwZHc5R0t2TkNyQjJhQjU0Z2IydVY5TWZRQyIsCiAgImFjY291bnQiOiB7CiAgICAibGFtcG9ydHMiOiAxMTQxNDQwLAogICAgImRhdGEiOiBbCiAgICAgICJBZ0FBQUg1Vks4U0l6akpmR1laYTRUSHgrS00vY1crcHp0TVovbzF0cVRwQk1MSy8iLAogICAgICAiYmFzZTY0IgogICAgXSwKICAgICJvd25lciI6ICJCUEZMb2FkZXJVcGdyYWRlYWIxZTExMTExMTExMTExMTExMTExMTExMTExIiwKICAgICJleGVjdXRhYmxlIjogdHJ1ZSwKICAgICJyZW50RXBvY2giOiAxNDUKICB9Cn0K)).
This is the account which contains the actual program data to compare to.

Strip the metadata from the account to get the raw binary:

```bash
solana account 9W9hLqpqjncrV1iYf2D3dt6WQMthM2SBBQ9Q5Rr6ueLn --output json | \
    jq -r .account.data[0] | base64 -d | tail -c +46 | head -c -37 > wormhole-onchain.so

sha256sum wormhole-onchain.so
```

This should get you the same checksum as above, verifying that the on-chain contract is indeed identical.
