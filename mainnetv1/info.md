# Wormhole Mainnet

This Wormhole mainnet connects the following chains:

- Solana [Mainnet Beta](https://docs.solana.com/clusters#mainnet-beta).

- Ethereum Mainnet.

## Network parameters

Gossip network name:

    /wormhole/mainnet/1

Gossip bootstrap node:

    /dns4/wormhole-mainnet-bootstrap.certus.one/udp/8999/quic/p2p/<TODO>

Connected chain contracts:

| Network             | Bridge contract addresss                       |
|---------------------|------------------------------------------------|
| Ethereum Mainnet    | [`0xf92cD566Ea4864356C5491c177A430C222d7e678`](https://etherscan.io/address/0xf92cD566Ea4864356C5491c177A430C222d7e678) (verified on Etherscan) |
| Solana Mainnet Beta | [`WormGDcAz3cSGyfBmhvJuufZTqqEkHCGUGSF5sRLb3U`](https://explorer.solana.com/address/WormGDcAz3cSGyfBmhvJuufZTqqEkHCGUGSF5sRLb3U?cluster=mainnet-beta) |

A copy of the contract binaries that were deployed can be found in [artifacts/](artifacts), along with a pointer to the
Wormhole revision that they were built from.

## Guardian set

Current generation: **0**, containing only the Certus One bootstrap node with the
address `TODO`.

See [v1.prototext](guardianset/v1.prototxt) for the first guardian set update that will be executed once everyone's
node on the network is live.

## Example command line options

Refer to the [operations guide](https://github.com/certusone/wormhole/blob/master/docs/operations.md) on how to set up a node.

```bash
/usr/local/bin/guardiand bridge \
    --bootstrap "/dns4/wormhole-mainnet-bootstrap.certus.one/udp/8999/quic/p2p/12D3KooWNMWC62BBEGgwuvTP1RGroSKbn8DNRubUKBcGwkrDk9dy"
    --network "/wormhole/mainnet/1" \
    --ethContract "0xf92cD566Ea4864356C5491c177A430C222d7e678" \
    --nodeName "Certus One" \                                # <-- your node's name (for network explorer usage)
    --nodeKey /opt/wormhole/keys/wormhole-node.key \         # <-- auto-generated node key
    --bridgeKey /opt/wormhole/keys/wormhole-guardian.key \   # <-- your guardian key generated by "guardiand keygen"
    --ethRPC wss://ethereum-node.example.com/ws/v3/[...] \   # <-- your ETH full/light node websocket URI
    --adminSocket /run/guardiand/admin.socket \
    --agentRPC /run/guardiand/agent.socket
```

```bash
/usr/local/bin/guardiand-solana-agent \
    --bridge WormGDcAz3cSGyfBmhvJuufZTqqEkHCGUGSF5sRLb3U \
    --rpc http://solana-host:8899 \     # <-- URL of your Solana validator RPC server
    --ws ws://solana-devnet:8900 \      # <-- Websocket path to your Solana validator PubSub port (RPC port +1)
    --keypair /path/to/feepayer.json \  # <-- Keypair of a Solana fee payer account with ~10 SOL in it
    --socket /run/guardiand/agent.socket
```

Your fee payer account should be funded with at least 15 SOL and not drop below 5 SOL.

## Contract verification

### Ethereum

Ethereum contracts are easily verified by standard tooling, for example, Etherscan's contract verification which
Wormhole's source code was uploaded to:

- [Wormhole.sol](https://etherscan.io/address/0xf92cD566Ea4864356C5491c177A430C222d7e678#contracts)
- [WrappedAsset.sol](https://etherscan.io/address/0x9A5e27995309a03f8B583feBdE7eF289FcCdC6Ae#contracts)

### Solana

On Solana, first compile the contract using the exact same version of the toolchain. The Wormhole dev environment pins
all dependencies to achieve a reproducible build:

```bash
cd wormhole/solana
git checkout 41361c1b3f7cfaf9c2e60a5cb22a14a20baf3abd

docker build -t wormhole-contract .
docker create --name wormhole-contract wormhole-contract
docker cp wormhole-contract:/opt/solana/deps/spl_bridge.so wormhole.sol
docker rm wormhole-contract

sha256sum wormhole.so
```

The checksum should be `d84a72c0d58fd92e4b9d0aed3fcb248c23073b09b329973944c378b62e92b70e`.

Now, compare it with the contract deployed on-chain. First, get the program account:

```bash
$ solana account WormGDcAz3cSGyfBmhvJuufZTqqEkHCGUGSF5sRLb3U --output json 
{
  "pubkey": "WormGDcAz3cSGyfBmhvJuufZTqqEkHCGUGSF5sRLb3U",
  "account": {
    "lamports": 1141440,
    "data": [
      "AgAAADpniauuXrg1mLYNBZljMl5uXFKk/gP+JsxdxZT0nsOP",
      "base64"
    ],
    "owner": "BPFLoaderUpgradeab1e11111111111111111111111",
    "executable": true,
    "rentEpoch": 142
  }
}
```

The address of the program data is stored in the program account's data:

```
0000:   02 00 00 00  3a 67 89 ab  ae 5e b8 35  98 b6 0d 05   ....:g...^.5....
0010:   99 63 32 5e  6e 5c 52 a4  fe 03 fe 26  cc 5d c5 94   .c2^n\R....&.]..
0020:   f4 9e c3 8f                                          ....
```

Drop the `02 00 00 00` prefix (=upgradeable program) and convert the address to Base58. You'll get
`4vzDWxxQtJSn9Xvu2J3tpa9gFCg23Pix86w5gUJbBnMc` ([example conversion using CyberChef](https://gchq.github.io/CyberChef/#recipe=JPath_expression('account.data%5B0%5D','%5C%5Cn')From_Base64('A-Za-z0-9%2B/%3D',true)Drop_bytes(0,4,false)To_Base58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz')&input=ewogICJwdWJrZXkiOiAiV29ybUdEY0F6M2NTR3lmQm1odkp1dWZaVHFxRWtIQ0dVR1NGNXNSTGIzVSIsCiAgImFjY291bnQiOiB7CiAgICAibGFtcG9ydHMiOiAxMTQxNDQwLAogICAgImRhdGEiOiBbCiAgICAgICJBZ0FBQURwbmlhdXVYcmcxbUxZTkJabGpNbDV1WEZLay9nUCtKc3hkeFpUMG5zT1AiLAogICAgICAiYmFzZTY0IgogICAgXSwKICAgICJvd25lciI6ICJCUEZMb2FkZXJVcGdyYWRlYWIxZTExMTExMTExMTExMTExMTExMTExMTExIiwKICAgICJleGVjdXRhYmxlIjogdHJ1ZSwKICAgICJyZW50RXBvY2giOiAxNDIKICB9Cn0K)).
This is the account which contains the actual program data to compare to.

Strip the metadata from the account to get the raw binary:

```bash
solana account 4vzDWxxQtJSn9Xvu2J3tpa9gFCg23Pix86w5gUJbBnMc --output json | \
    jq -r .account.data[0] | base64 -d | tail -c +46 | head -c -37 > wormhole-onchain.so

sha256sum wormhole-onchain.so
```

This should get you the same checksum as above, verifying that the on-chain contract is indeed identical.
